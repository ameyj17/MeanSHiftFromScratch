# -*- coding: utf-8 -*-
"""CalcMeanShiftCV.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16Af6wZHqFQtzElw2927ggHyZAoGMeHgO
"""

import numpy as np
from PIL import Image

# Example array with shape (480, 480) and uint8 data type
array = cv2.imread("img1.png")

# Create an image object from the array
image = Image.fromarray(array)
print(shape(image))
# Verify the image
image.show()

from numpy.core.fromnumeric import shape
import cv2
from google.colab.patches import cv2_imshow

# Load the image
image = cv2.imread("img1.png")

# Check if the image was successfully loaded
if image is not None:
    # Convert the image to LUV color space
    luv_image = cv2.cvtColor(image, cv2.COLOR_BGR2LUV)
    print(shape(luv_image))
    # Extract the L channel
    L_channel = luv_image[:, :, 0]
    print(shape(L_channel))

    # Display the L channel image
    cv2_imshow(L_channel)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
else:
    print("Image not found or unable to load.")

import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

def mean_shift_estimation(img, spatial_radius, range_radius, max_iterations=100):
    # Convert image to LUV color space
    luv_img = cv2.cvtColor(img, cv2.COLOR_RGB2LUV)

    height, width, _ = luv_img.shape

    # Convert image to feature space
    feature_space = np.reshape(luv_img, (height * width, 3))

    for _ in range(max_iterations):
        # Calculate spatial and range weights using truncated Gaussian distribution
        spatial_weights = np.exp(-np.sum(np.square(feature_space[:, :2] / spatial_radius), axis=1))
        range_weights = np.exp(-np.sum(np.square(feature_space[:, 1:] / range_radius), axis=1))

        # Calculate mean shift vector
        mean_shift = np.sum(feature_space * spatial_weights[:, np.newaxis] * range_weights[:, np.newaxis], axis=0) / \
                     np.sum(spatial_weights[:, np.newaxis] * range_weights[:, np.newaxis], axis=0)

        # Update feature space with mean shift vector
        feature_space = (feature_space + mean_shift).astype(np.uint8)

    # Reshape feature space back to image shape
    result_img = np.reshape(feature_space, (height, width, 3))

    # Convert image back to RGB color space
    result_img = cv2.cvtColor(result_img, cv2.COLOR_LUV2RGB)

    return result_img

# Load image
image_path = 'img1.png'
original_image = Image.open(image_path).convert("RGB")
original_image_np = np.array(original_image)

# Set parameters for mean shift
spatial_radius = 20
range_radius = 50
max_iterations = 100

# Perform mean shift image smoothing
smoothed_image = mean_shift_estimation(original_image_np, spatial_radius, range_radius, max_iterations)

# Display the original and smoothed images
fig, axs = plt.subplots(1, 2, figsize=(10, 5))
axs[0].imshow(original_image)
axs[0].set_title('Original Image')
axs[0].axis('off')
axs[1].imshow(smoothed_image)
axs[1].set_title('Smoothed Image')
axs[1].axis('off')
plt.show()

import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

def mean_shift_segmentation(image_path, spatial_radius, range_radius):
    # Load image using PIL
    img = Image.open(image_path)
    img = np.array(img)

    # Convert image to RGB color space
    rgb_img = cv2.cvtColor(img, cv2.COLOR_RGBA2RGB)

    # Convert image to 8-bit format
    rgb_img = np.uint8(rgb_img)

    # Perform mean shift segmentation
    segmented_img = cv2.pyrMeanShiftFiltering(rgb_img, spatial_radius, range_radius)

    return segmented_img

# Set the parameters for the Mean Shift algorithm
spatial_radius = 10
range_radius = 20

# Perform Mean Shift segmentation on the image
segmented_image = mean_shift_segmentation('img1.png', spatial_radius, range_radius)

# Display the original and segmented images using Matplotlib
fig, ax = plt.subplots(1, 2, figsize=(10, 5))
ax[0].imshow(Image.open('img1.png'))
ax[0].set_title('Original Image')
ax[0].axis('off')
ax[1].imshow(segmented_image)
ax[1].set_title('Segmented Image')
ax[1].axis('off')
plt.show()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
from PIL import Image


def range_kernel(L, sigma_r):
    L_diff_sq = (L[:, :, np.newaxis] - L[np.newaxis, np.newaxis, :]) ** 2
    range_kernel_values = np.exp(-L_diff_sq / (2 * sigma_r ** 2))
    return range_kernel_values

def spatial_kernel(height, width, sigma_s):
    x, y = np.meshgrid(np.arange(width), np.arange(height))
    spatial_distance_sq = (x[:, :, np.newaxis] - x[np.newaxis, np.newaxis, :]) ** 2 + (y[:, :, np.newaxis] - y[np.newaxis, np.newaxis, :]) ** 2
    spatial_kernel_values = np.exp(-spatial_distance_sq / (2 * sigma_s ** 2))
    return spatial_kernel_values


# Load the input image
image = cv2.imread("img1_L.jpg")

# Convert the image to LUV color space
luv_image = cv2.cvtColor(image, cv2.COLOR_BGR2LUV)

# Extract the L channel
L_channel = luv_image[:, :, 0]

# Set the bandwidths for the range and spatial kernels
hs_bandwidth = 50
hr_bandwidth = 50

# Calculate the range kernel density map
hs_density_map = range_kernel(L_channel, hs_bandwidth)

# Calculate the spatial kernel density map
hr_density_map = spatial_kernel(L_channel.shape[0], L_channel.shape[1], hr_bandwidth)

# Display the density maps (for visualization purposes)
cv2_imshow(hs_density_map)
cv2_imshow(hr_density_map)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

def bgr_to_luv(image):
    luv_image = cv2.cvtColor(image, cv2.COLOR_BGR2LUV)
    return luv_image

def bgr_to_lab(image):
    lab_image = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
    return lab_image

def mean_shift_segmentation(image, spatial_radius, range_radius, min_density):
    # Convert the image to LUV color space
    luv_image = bgr_to_luv(image)

    # Convert the LUV image to a numpy array
    luv_array = np.array(luv_image)

    # Normalize the LUV values to [0, 1] range
    luv_array = luv_array.astype(np.float32) / np.array([100, 354, 256])

    # Compute the spatial and range kernels
    spatial_kernel = create_spatial_kernel(spatial_radius)
    range_kernel = create_range_kernel(range_radius)

    # Resize the spatial kernel to match the range kernel
    resized_spatial_kernel = cv2.resize(spatial_kernel, range_kernel.shape[::-1])

    # Compute the weighted sum of the spatial and range kernels
    kernel = resized_spatial_kernel[:, :, np.newaxis] * range_kernel

    # Reshape the image and kernel arrays
    luv_vector = luv_array.reshape(-1, 3)
    kernel_vector = kernel.reshape(-1, 1)

    # Perform mean shift iterations until convergence
    density_updated = True
    while density_updated:
        density_updated = False
        updated_points = np.zeros_like(luv_vector)

        for i, point in enumerate(luv_vector):
            weights = kernel_vector * np.exp(-np.linalg.norm(point - luv_vector, axis=1) ** 2)

            updated_point = np.sum(weights.reshape(-1, 1) * luv_vector, axis=0) / np.sum(weights)
            updated_points[i] = updated_point

            if np.linalg.norm(updated_point - point) > min_density:
                density_updated = True

        luv_vector = updated_points

    # Reshape the updated points back to the original image shape
    updated_image = luv_vector.reshape(image.shape)

    # Convert the updated image back to BGR color space
    updated_image = (updated_image * np.array([100, 354, 256])).astype(np.uint8)
    updated_image = cv2.cvtColor(updated_image, cv2.COLOR_LUV2BGR)

    return updated_image

def create_spatial_kernel(radius):
    size = 2 * radius + 1
    kernel = np.zeros((size, size))
    for i in range(size):
        for j in range(size):
            distance = np.sqrt((i - radius) ** 2 + (j - radius) ** 2)
            if distance <= radius:
                kernel[i, j] = 1
    return kernel


def create_range_kernel(radius):
    size = 2 * radius + 1
    kernel = np.zeros((size, size))
    for i in range(size):
        for j in range(size):
            distance = np.sqrt((i - radius) ** 2 + (j - radius) ** 2)
            if distance <= radius:
                kernel[i, j] = 1
    return kernel


# Load the image
image_path = "img1_L.jpg"
image = cv2.imread(image_path)

# Perform mean shift segmentation
segmented_image = mean_shift_segmentation(image, spatial_radius=375, range_radius=390, min_density=0.1)

# Display the original and segmented images
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.title("Original Image")

plt.subplot(1, 2, 2)
plt.imshow(cv2.cvtColor(segmented_image, cv2.COLOR_BGR2RGB))
plt.title("Segmented Image")

plt.show()

